// Autogenerated by genbin.go

package mirror

import (
	"reflect"
	"testing"
	"testing/quick"
)

// TestLorBool
func TestLorBool(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y bool) bool {
				gote := Lor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x || y
				return FlexEqual(got, want)
			},
			typ: "bool",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLandBool
func TestLandBool(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y bool) bool {
				gote := Land(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x && y
				return FlexEqual(got, want)
			},
			typ: "bool",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlInt
func TestEqlInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlUint
func TestEqlUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlFloat
func TestEqlFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlComplex
func TestEqlComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlString
func TestEqlString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestEqlBool
func TestEqlBool(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y bool) bool {
				gote := Eql(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x == y
				return FlexEqual(got, want)
			},
			typ: "bool",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqInt
func TestNeqInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqUint
func TestNeqUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqFloat
func TestNeqFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqComplex
func TestNeqComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqString
func TestNeqString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestNeqBool
func TestNeqBool(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y bool) bool {
				gote := Neq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x != y
				return FlexEqual(got, want)
			},
			typ: "bool",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLssInt
func TestLssInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLssUint
func TestLssUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLssFloat
func TestLssFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLssString
func TestLssString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Lss(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x < y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGtrInt
func TestGtrInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGtrUint
func TestGtrUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGtrFloat
func TestGtrFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGtrString
func TestGtrString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Gtr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x > y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLeqInt
func TestLeqInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLeqUint
func TestLeqUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLeqFloat
func TestLeqFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestLeqString
func TestLeqString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Leq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x <= y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGeqInt
func TestGeqInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGeqUint
func TestGeqUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGeqFloat
func TestGeqFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestGeqString
func TestGeqString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Geq(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(bool)
				want := x >= y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAddInt
func TestAddInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAddUint
func TestAddUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAddFloat
func TestAddFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float32)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float64)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAddComplex
func TestAddComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex64)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex128)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAddString
func TestAddString(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y string) bool {
				gote := Add(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(string)
				want := x + y
				return FlexEqual(got, want)
			},
			typ: "string",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestSubInt
func TestSubInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestSubUint
func TestSubUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestSubFloat
func TestSubFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float32)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float64)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestSubComplex
func TestSubComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex64)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Sub(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex128)
				want := x - y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestOrInt
func TestOrInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestOrUint
func TestOrUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Or(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x | y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestXorInt
func TestXorInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestXorUint
func TestXorUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Xor(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x ^ y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestMulInt
func TestMulInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestMulUint
func TestMulUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestMulFloat
func TestMulFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float32)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float64)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestMulComplex
func TestMulComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex64)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Mul(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex128)
				want := x * y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestQuoInt
func TestQuoInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestQuoUint
func TestQuoUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestQuoFloat
func TestQuoFloat(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y float32) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float32)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "float32",
		},
		{
			f: func(x, y float64) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(float64)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "float64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestQuoComplex
func TestQuoComplex(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y complex64) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex64)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "complex64",
		},
		{
			f: func(x, y complex128) bool {
				gote := Quo(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(complex128)
				want := x / y
				return FlexEqual(got, want)
			},
			typ: "complex128",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestRemInt
func TestRemInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestRemUint
func TestRemUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := Rem(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x % y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAndInt
func TestAndInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAndUint
func TestAndUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := And(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x & y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAndNotInt
func TestAndNotInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y int) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x, y int8) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x, y int16) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x, y int32) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x, y int64) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestAndNotUint
func TestAndNotUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x, y uint) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x, y uint8) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x, y uint16) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x, y uint32) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x, y uint64) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x, y uintptr) bool {
				gote := AndNot(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x &^ y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestShlInt
func TestShlInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x int, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x int8, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x int16, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x int32, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x int64, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestShlUint
func TestShlUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x uint, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x uint8, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x uint16, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x uint32, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x uint64, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x uintptr, y uint64) bool {
				gote := Shl(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x << y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestShrInt
func TestShrInt(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x int, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "int",
		},
		{
			f: func(x int8, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int8)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "int8",
		},
		{
			f: func(x int16, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int16)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "int16",
		},
		{
			f: func(x int32, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int32)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "int32",
		},
		{
			f: func(x int64, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(int64)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "int64",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

// TestShrUint
func TestShrUint(t *testing.T) {
	tests := []struct {
		f   interface{}
		typ string
	}{
		{
			f: func(x uint, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uint",
		},
		{
			f: func(x uint8, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint8)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uint8",
		},
		{
			f: func(x uint16, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint16)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uint16",
		},
		{
			f: func(x uint32, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint32)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uint32",
		},
		{
			f: func(x uint64, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uint64)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uint64",
		},
		{
			f: func(x uintptr, y uint64) bool {
				gote := Shr(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				got := gote.(uintptr)
				want := x >> y
				return FlexEqual(got, want)
			},
			typ: "uintptr",
		},
	}
	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}
