// Autogenerated by genbin.go

package mirror

import (
	"fmt"
	"reflect"
)

// Lor implements the binary || op.
// Lor panics if x and y have different types
// or are of a type incompatible with ||.
func Lor(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Bool:
		xx := bool(x.Bool())
		yy := bool(y.Bool())
		zz := bool(xx || yy)
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator || not defined on %v", x.Type()))
}

// Land implements the binary && op.
// Land panics if x and y have different types
// or are of a type incompatible with &&.
func Land(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Bool:
		xx := bool(x.Bool())
		yy := bool(y.Bool())
		zz := bool(xx && yy)
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator && not defined on %v", x.Type()))
}

// Eql implements the binary == op.
// Eql panics if x and y have different types
// or are of a type incompatible with ==.
func Eql(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx == yy
		z.SetBool(zz)
		return z
	case reflect.Bool:
		xx := bool(x.Bool())
		yy := bool(y.Bool())
		zz := xx == yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator == not defined on %v", x.Type()))
}

// Neq implements the binary != op.
// Neq panics if x and y have different types
// or are of a type incompatible with !=.
func Neq(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx != yy
		z.SetBool(zz)
		return z
	case reflect.Bool:
		xx := bool(x.Bool())
		yy := bool(y.Bool())
		zz := xx != yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator != not defined on %v", x.Type()))
}

// Lss implements the binary < op.
// Lss panics if x and y have different types
// or are of a type incompatible with <.
func Lss(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx < yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx < yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator < not defined on %v", x.Type()))
}

// Gtr implements the binary > op.
// Gtr panics if x and y have different types
// or are of a type incompatible with >.
func Gtr(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx > yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx > yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator > not defined on %v", x.Type()))
}

// Leq implements the binary <= op.
// Leq panics if x and y have different types
// or are of a type incompatible with <=.
func Leq(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx <= yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator <= not defined on %v", x.Type()))
}

// Geq implements the binary >= op.
// Geq panics if x and y have different types
// or are of a type incompatible with >=.
func Geq(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(reflect.TypeOf(false)).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := xx >= yy
		z.SetBool(zz)
		return z
	}
	panic(fmt.Sprintf("operator >= not defined on %v", x.Type()))
}

// Add implements the binary + op.
// Add panics if x and y have different types
// or are of a type incompatible with +.
func Add(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx + yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx + yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx + yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx + yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx + yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx + yy)
		z.SetUint(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := float64(xx + yy)
		z.SetFloat(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := float64(xx + yy)
		z.SetFloat(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := complex128(xx + yy)
		z.SetComplex(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := complex128(xx + yy)
		z.SetComplex(zz)
		return z
	case reflect.String:
		xx := string(x.String())
		yy := string(y.String())
		zz := string(xx + yy)
		z.SetString(zz)
		return z
	}
	panic(fmt.Sprintf("operator + not defined on %v", x.Type()))
}

// Sub implements the binary - op.
// Sub panics if x and y have different types
// or are of a type incompatible with -.
func Sub(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx - yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx - yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx - yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx - yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx - yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx - yy)
		z.SetUint(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := float64(xx - yy)
		z.SetFloat(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := float64(xx - yy)
		z.SetFloat(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := complex128(xx - yy)
		z.SetComplex(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := complex128(xx - yy)
		z.SetComplex(zz)
		return z
	}
	panic(fmt.Sprintf("operator - not defined on %v", x.Type()))
}

// Or implements the binary | op.
// Or panics if x and y have different types
// or are of a type incompatible with |.
func Or(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx | yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx | yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx | yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx | yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx | yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx | yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator | not defined on %v", x.Type()))
}

// Xor implements the binary ^ op.
// Xor panics if x and y have different types
// or are of a type incompatible with ^.
func Xor(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx ^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx ^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx ^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx ^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx ^ yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx ^ yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator ^ not defined on %v", x.Type()))
}

// Mul implements the binary * op.
// Mul panics if x and y have different types
// or are of a type incompatible with *.
func Mul(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx * yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx * yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx * yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx * yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx * yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx * yy)
		z.SetUint(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := float64(xx * yy)
		z.SetFloat(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := float64(xx * yy)
		z.SetFloat(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := complex128(xx * yy)
		z.SetComplex(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := complex128(xx * yy)
		z.SetComplex(zz)
		return z
	}
	panic(fmt.Sprintf("operator * not defined on %v", x.Type()))
}

// Quo implements the binary / op.
// Quo panics if x and y have different types
// or are of a type incompatible with /.
func Quo(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx / yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx / yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx / yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx / yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx / yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx / yy)
		z.SetUint(zz)
		return z
	case reflect.Float32:
		xx := float32(x.Float())
		yy := float32(y.Float())
		zz := float64(xx / yy)
		z.SetFloat(zz)
		return z
	case reflect.Float64:
		xx := float64(x.Float())
		yy := float64(y.Float())
		zz := float64(xx / yy)
		z.SetFloat(zz)
		return z
	case reflect.Complex64:
		xx := complex64(x.Complex())
		yy := complex64(y.Complex())
		zz := complex128(xx / yy)
		z.SetComplex(zz)
		return z
	case reflect.Complex128:
		xx := complex128(x.Complex())
		yy := complex128(y.Complex())
		zz := complex128(xx / yy)
		z.SetComplex(zz)
		return z
	}
	panic(fmt.Sprintf("operator / not defined on %v", x.Type()))
}

// Rem implements the binary % op.
// Rem panics if x and y have different types
// or are of a type incompatible with %.
func Rem(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx % yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx % yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx % yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx % yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx % yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx % yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator % not defined on %v", x.Type()))
}

// And implements the binary & op.
// And panics if x and y have different types
// or are of a type incompatible with &.
func And(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx & yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx & yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx & yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx & yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx & yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx & yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator & not defined on %v", x.Type()))
}

// AndNot implements the binary &^ op.
// AndNot panics if x and y have different types
// or are of a type incompatible with &^.
func AndNot(x, y reflect.Value) reflect.Value {
	mustSameType(x, y)
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		yy := int(y.Int())
		zz := int64(xx &^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		yy := int8(y.Int())
		zz := int64(xx &^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		yy := int16(y.Int())
		zz := int64(xx &^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		yy := int32(y.Int())
		zz := int64(xx &^ yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		yy := int64(y.Int())
		zz := int64(xx &^ yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		yy := uint(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		yy := uint8(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		yy := uint16(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		yy := uint32(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		yy := uint64(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		yy := uintptr(y.Uint())
		zz := uint64(xx &^ yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator &^ not defined on %v", x.Type()))
}

// Shl implements the binary << op.
// Shl panics if x's kind is not an integer (signed or unsigned)
// or y's kind is not an unsigned integer.
func Shl(x, y reflect.Value) reflect.Value {
	mustUnsigned(y)
	yy := y.Uint()
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		zz := int64(xx << yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		zz := int64(xx << yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		zz := int64(xx << yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		zz := int64(xx << yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		zz := int64(xx << yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		zz := uint64(xx << yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator << not defined on %v", x.Type()))
}

// Shr implements the binary >> op.
// Shr panics if x's kind is not an integer (signed or unsigned)
// or y's kind is not an unsigned integer.
func Shr(x, y reflect.Value) reflect.Value {
	mustUnsigned(y)
	yy := y.Uint()
	z := reflect.New(x.Type()).Elem()
	switch x.Type().Kind() {
	case reflect.Int:
		xx := int(x.Int())
		zz := int64(xx >> yy)
		z.SetInt(zz)
		return z
	case reflect.Int8:
		xx := int8(x.Int())
		zz := int64(xx >> yy)
		z.SetInt(zz)
		return z
	case reflect.Int16:
		xx := int16(x.Int())
		zz := int64(xx >> yy)
		z.SetInt(zz)
		return z
	case reflect.Int32:
		xx := int32(x.Int())
		zz := int64(xx >> yy)
		z.SetInt(zz)
		return z
	case reflect.Int64:
		xx := int64(x.Int())
		zz := int64(xx >> yy)
		z.SetInt(zz)
		return z
	case reflect.Uint:
		xx := uint(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	case reflect.Uint8:
		xx := uint8(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	case reflect.Uint16:
		xx := uint16(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	case reflect.Uint32:
		xx := uint32(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	case reflect.Uint64:
		xx := uint64(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	case reflect.Uintptr:
		xx := uintptr(x.Uint())
		zz := uint64(xx >> yy)
		z.SetUint(zz)
		return z
	}
	panic(fmt.Sprintf("operator >> not defined on %v", x.Type()))
}
