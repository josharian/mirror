// +build ignore

// genbin generates bin.go and bin_test.go

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

func generate(fname string, tmpl string) error {
	var buf bytes.Buffer

	t := template.Must(template.New("").Funcs(template.FuncMap{"title": strings.Title}).Parse(tmpl))
	for _, op := range binops {
		if err := t.Execute(&buf, op); err != nil {
			return err
		}
	}

	// Remove stupid newlines everywhere.
	// It is frustrating that I can't have templates that are readable
	// without introducing lots of unwanted newlines.
	src := buf.Bytes()
	lines := bytes.Split(src, []byte("\n"))
	for i := 0; i < len(lines); i++ {
		line := lines[i]
		if len(bytes.TrimSpace(line)) == 0 {
			copy(lines[i:], lines[i+1:])
			lines = lines[:len(lines)-1]
			i--
		}
	}
	src = bytes.Join(lines, []byte("\n"))

	// Prepend preamble after removing blank lines so that the comment
	// in the preamble doesn't become part of the package godoc. Sigh.
	src = append(preamble, src...)

	src, err := imports.Process("", src, nil)
	if err != nil {
		fmt.Println(buf.String())
		return err
	}

	if err := ioutil.WriteFile(fname, src, 0644); err != nil {
		return err
	}

	return nil
}

func main() {
	if err := generate("bin.go", fns); err != nil {
		log.Fatal(err)
	}
	if err := generate("bin_test.go", tests); err != nil {
		log.Fatal(err)
	}
}

type Op struct {
	Name  string
	Tok   string
	Rel   bool // is a relational op (returns bool instead of input types)
	Shift bool // is a shift op (rhs must be unsigned)
	Types []Types
}

var binops = []Op{
	// logical ops
	{Name: "Lor", Tok: "||", Types: BoolOnly},
	{Name: "Land", Tok: "&&", Types: BoolOnly},

	// rel ops
	{Name: "Eql", Tok: "==", Rel: true, Types: All},
	{Name: "Neq", Tok: "!=", Rel: true, Types: All},
	{Name: "Lss", Tok: "<", Rel: true, Types: RealString},
	{Name: "Gtr", Tok: ">", Rel: true, Types: RealString},
	{Name: "Leq", Tok: "<=", Rel: true, Types: RealString},
	{Name: "Geq", Tok: ">=", Rel: true, Types: RealString},

	// add ops
	{Name: "Add", Tok: "+", Types: NumericString},
	{Name: "Sub", Tok: "-", Types: AllNumeric},
	{Name: "Or", Tok: "|", Types: IntOnly},
	{Name: "Xor", Tok: "^", Types: IntOnly},

	// mul ops
	{Name: "Mul", Tok: "*", Types: AllNumeric},
	{Name: "Quo", Tok: "/", Types: AllNumeric},
	{Name: "Rem", Tok: "%", Types: IntOnly},
	{Name: "And", Tok: "&", Types: IntOnly},
	{Name: "AndNot", Tok: "&^", Types: IntOnly},
	{Name: "Shl", Tok: "<<", Shift: true, Types: IntOnly},
	{Name: "Shr", Tok: ">>", Shift: true, Types: IntOnly},
}

type Types struct {
	Class string   // class of type, in title case (Int, Uint, Float)
	Max   string   // largest type (Int64, Complex64)
	Names []string // names of all types
}

var (
	IntTypes   = Types{Class: "Int", Max: "int64", Names: []string{"int", "int8", "int16", "int32", "int64"}}
	UintTypes  = Types{Class: "Uint", Max: "uint64", Names: []string{"uint", "uint8", "uint16", "uint32", "uint64", "uintptr"}}
	FloatTypes = Types{Class: "Float", Max: "float64", Names: []string{"float32", "float64"}}
	CmplxTypes = Types{Class: "Complex", Max: "complex128", Names: []string{"complex64", "complex128"}}
	StrTypes   = Types{Class: "String", Max: "string", Names: []string{"string"}}
	BoolTypes  = Types{Class: "Bool", Max: "bool", Names: []string{"bool"}}
)

var (
	All           = []Types{IntTypes, UintTypes, FloatTypes, CmplxTypes, StrTypes, BoolTypes}
	AllNumeric    = []Types{IntTypes, UintTypes, FloatTypes, CmplxTypes}
	IntOnly       = []Types{IntTypes, UintTypes}
	RealString    = []Types{IntTypes, UintTypes, FloatTypes, StrTypes}
	NumericString = []Types{IntTypes, UintTypes, FloatTypes, CmplxTypes, StrTypes}
	BoolOnly      = []Types{BoolTypes}
)

var preamble = []byte(`
// Autogenerated by genbin.go

package mirror
`)

const tests = `
{{$name := .Name}}
{{$op := .Tok}}
{{$rel := .Rel}}
{{$shift := .Shift}}

{{range .Types}}

{{$max := .Max}}

{{/* The meaningless comment is to make gofmt print a blank line between functions.*/}}
// Test{{$name}}{{.Class}}
func Test{{$name}}{{.Class}}(t *testing.T) {
	tests := []struct {
		f	interface{}
		typ	string
	}{
	{{range .Names}}
		{
			{{if $shift}}
			f: func(x {{.}}, y uint64) bool {
			{{else}}
			f: func(x, y {{.}}) bool {
			{{end}}
				gote := {{$name}}(reflect.ValueOf(x), reflect.ValueOf(y)).Interface()
				{{if $rel}}
				got := gote.(bool)
				{{else}}
				got := gote.({{.}})
				{{end}}
				want := x {{$op}} y
				return FlexEqual(got, want)
			},
			typ: "{{.}}",
		},
	{{end}}
	}

	for _, tt := range tests {
		if err := quick.Check(tt.f, nil); err != nil {
			t.Error(tt.typ, err)
		}
	}
}

{{end}}
`

const fns = `
{{$op := .Tok}}
{{$rel := .Rel}}
{{$shift := .Shift}}

// {{.Name}} implements the binary {{.Tok}} op.
{{if $shift}}
// {{.Name}} panics if x's kind is not an integer (signed or unsigned)
// or y's kind is not an unsigned integer.
{{else}}
// {{.Name}} panics if x and y have different types
// or are of a type incompatible with {{.Tok}}.
{{end}}
func {{.Name}}(x, y reflect.Value) reflect.Value {
	{{if $shift}}
	mustUnsigned(y)
	yy := y.Uint()
	{{else}}
	mustSameType(x, y)
	{{end}}

	{{if $rel}}
	z := reflect.New(reflect.TypeOf(false)).Elem()
	{{else}}
	z := reflect.New(x.Type()).Elem()
	{{end}}

	switch x.Type().Kind() {
	{{range $, $types := .Types}}
		{{$max := .Max}}
		{{$class := .Class}}

		{{range .Names}}
		case reflect.{{title .}}:
			xx := {{.}}(x.{{$class}}())
			{{if not $shift}}
			yy := {{.}}(y.{{$class}}())
			{{end}}
			{{if $rel}}
			zz := xx {{$op}} yy
			z.SetBool(zz)
			{{else}}
			zz := {{$max}}(xx {{$op}} yy)
			z.Set{{$class}}(zz)
			{{end}}
			return z
		{{end}}

	{{end}}
	}

	panic(fmt.Sprintf("operator {{$op}} not defined on %v", x.Type()))
}
`
